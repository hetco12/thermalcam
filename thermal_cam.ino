//this is better with included zip package that has all needed libraries in it for testing.
//most updated version of thermal_cam file can replace the one in zip file
//this is a work in process. 16x16 subsample seems to work ok, trying to verify 32x32 and add up to 512 by 512
//some changes may be needed to have includes location changes also spixx.h just uses libray in file change back to <spi.h>
//this is the only file that has changeds to display resolution, however there are changes that burst spi and 
//double lcd speed of rectangle draws. these are specific to using the libraries included here.
//if you want to use included setup, and have spi speed, then set #define spi_optimized_st77xx true

//32x32 might need work. will need to first increase color table to be sure
//located here on github :https://github.com/jamesdanielv/thermalcam/edit/master/thermal_cam.ino
/***************************************************************************
  This is a library for the AMG88xx GridEYE 8x8 IR camera
  This sketch makes a 64 pixel thermal camera with the GridEYE sensor
  and a 128x128 tft screen https://www.adafruit.com/product/2088
  Designed specifically to work with the Adafruit AMG88 breakout
  ----> http://www.adafruit.com/products/3538
  These sensors use I2C to communicate. The device's I2C address is 0x69
  Adafruit invests time and resources providing this open source code,
  please support Adafruit andopen-source hardware by purchasing products
  from Adafruit!
  Written by Dean Miller for Adafruit Industries.
  BSD license, all text above must be included in any redistribution
 ***************************************************************************/

#include "Adafruit_GFX.h"    // Core graphics library
#include "Adafruit_ST7735.h" // Hardware-specific library
#include "SPIxx.h" //built in library should be SPI.h 
#include "Adafruit_SPITFT_Macros.h"
#include <Wire.h>
#include "Adafruit_AMG88xx.h"
#include <avr/pgmspace.h>

//these 3 will need to be redefined in Adafruit_ST77xx.ccp file for small amount of time. seems some slow pixel writing on arduino otherwise!
#define TFT_CS     10 //chip select pin for the TFT screen
#define TFT_RST    9  // you can also connect this to the Arduino reset
                      // in which case, set this #define pin to 0!
#define TFT_DC     8

//low range of the sensor (this will be blue on the screen)
#define MINTEMP 22

//high range of the sensor (this will be red on the screen)
#define MAXTEMP 34


// 0 no optimse |1 pixels only written whe color changed| 2 pixels also optimized for most changed ones first (deals with noise issues)
#define optimize 2

#define interpolatemode 1 //can be 0-2 so far 0=8x8 1=16x16 2=32x32 
//const dataType variableName[] PROGMEM = {data0, data1, data3…​};// how to formate table for progmem or the way it is listed. in order for it to work correctly int needs to be reconverted to  (uint16_t)
//the colors we will be using stored into a flash instead of ram which is valuable on arudino just use (uint16_t)pgm_read_word_near(camColors+ instead of Camcolors[]
#define colorMode 1  //can be 0=64 color adafruit, 1=256 color map 0,1 use same 256 color table , just 0 has same value 4 times
#define spi_optimized_st77xx false  //false if using normal driver//these files are upaded and specif for this code needed st77xx,h, st77xx.cpp need downloaded from https://github.com/jamesdanielv/thermalcam/blob/master/colorgenerator



#if spi_optimized_st77xx == true
#define fillRectFast tft.fillRectFast
#else
#define fillRectFast tft.fillRect
#endif

#if colorMode == 0
const PROGMEM uint16_t camColors[] =  {0x480F,
0x400F,0x400F,0x400F,0x4010,0x3810,0x3810,0x3810,0x3810,0x3010,0x3010,
0x3010,0x2810,0x2810,0x2810,0x2810,0x2010,0x2010,0x2010,0x1810,0x1810,
0x1811,0x1811,0x1011,0x1011,0x1011,0x0811,0x0811,0x0811,0x0011,0x0011,
0x0011,0x0011,0x0011,0x0031,0x0031,0x0051,0x0072,0x0072,0x0092,0x00B2,
0x00B2,0x00D2,0x00F2,0x00F2,0x0112,0x0132,0x0152,0x0152,0x0172,0x0192,
0x0192,0x01B2,0x01D2,0x01F3,0x01F3,0x0213,0x0233,0x0253,0x0253,0x0273,
0x0293,0x02B3,0x02D3,0x02D3,0x02F3,0x0313,0x0333,0x0333,0x0353,0x0373,
0x0394,0x03B4,0x03D4,0x03D4,0x03F4,0x0414,0x0434,0x0454,0x0474,0x0474,
0x0494,0x04B4,0x04D4,0x04F4,0x0514,0x0534,0x0534,0x0554,0x0554,0x0574,
0x0574,0x0573,0x0573,0x0573,0x0572,0x0572,0x0572,0x0571,0x0591,0x0591,
0x0590,0x0590,0x058F,0x058F,0x058F,0x058E,0x05AE,0x05AE,0x05AD,0x05AD,
0x05AD,0x05AC,0x05AC,0x05AB,0x05CB,0x05CB,0x05CA,0x05CA,0x05CA,0x05C9,
0x05C9,0x05C8,0x05E8,0x05E8,0x05E7,0x05E7,0x05E6,0x05E6,0x05E6,0x05E5,
0x05E5,0x0604,0x0604,0x0604,0x0603,0x0603,0x0602,0x0602,0x0601,0x0621,
0x0621,0x0620,0x0620,0x0620,0x0620,0x0E20,0x0E20,0x0E40,0x1640,0x1640,
0x1E40,0x1E40,0x2640,0x2640,0x2E40,0x2E60,0x3660,0x3660,0x3E60,0x3E60,
0x3E60,0x4660,0x4660,0x4E60,0x4E80,0x5680,0x5680,0x5E80,0x5E80,0x6680,
0x6680,0x6E80,0x6EA0,0x76A0,0x76A0,0x7EA0,0x7EA0,0x86A0,0x86A0,0x8EA0,
0x8EC0,0x96C0,0x96C0,0x9EC0,0x9EC0,0xA6C0,0xAEC0,0xAEC0,0xB6E0,0xB6E0,
0xBEE0,0xBEE0,0xC6E0,0xC6E0,0xCEE0,0xCEE0,0xD6E0,0xD700,0xDF00,0xDEE0,
0xDEC0,0xDEA0,0xDE80,0xDE80,0xE660,0xE640,0xE620,0xE600,0xE5E0,0xE5C0,
0xE5A0,0xE580,0xE560,0xE540,0xE520,0xE500,0xE4E0,0xE4C0,0xE4A0,0xE480,
0xE460,0xEC40,0xEC20,0xEC00,0xEBE0,0xEBC0,0xEBA0,0xEB80,0xEB60,0xEB40,
0xEB20,0xEB00,0xEAE0,0xEAC0,0xEAA0,0xEA80,0xEA60,0xEA40,0xF220,0xF200,
0xF1E0,0xF1C0,0xF1A0,0xF180,0xF160,0xF140,0xF100,0xF0E0,0xF0C0,0xF0A0,
0xF080,0xF060,0xF040,0xF020,0xF800,};
#endif

#if colorMode == 1
const PROGMEM uint16_t camColors[] =  
{0x0004,0x0004,0x0005,0x0005,0x0006,0x0007,0x0007,
0x0008,0x0008,0x0009,0x0009,0x000a,0x000b,0x000b,
0x000c,0x000c,0x000d,0x000d,0x000e,0x000f,0x000f,
0x0010,0x0010,0x0011,0x0012,0x0012,0x0013,0x0013,
0x0014,0x0014,0x0015,0x0016,0x0016,0x0017,0x0017,
0x0018,0x0018,0x0019,0x001a,0x001a,0x001b,0x001b,
0x001c,0x001c,0x001d,0x001e,0x001e,0x001f,0x001f,
0x001f,0x003e,0x003e,0x005d,0x005d,0x007c,0x009b,
0x009b,0x00ba,0x00ba,0x00d9,0x00d8,0x00f8,0x0117,
0x0117,0x0136,0x0136,0x0155,0x0174,0x0174,0x0193,
0x0193,0x01b2,0x01b2,0x01d1,0x01f0,0x01f0,0x020f,
0x020f,0x022e,0x024d,0x024d,0x026c,0x026c,0x028b,
0x028b,0x02aa,0x02c9,0x02c9,0x02e8,0x02e8,0x0307,
0x0307,0x0326,0x0345,0x0345,0x0364,0x0364,0x0383,
0x03a3,0x03a2,0x03c1,0x03c1,0x03e0,0x03e0,0x0400,
0x0c20,0x0c20,0x1440,0x1440,0x1c60,0x1c60,0x2480,
0x2ca0,0x2ca0,0x34c0,0x34c0,0x3ce0,0x44e0,0x4500,
0x4d20,0x4d20,0x5540,0x5540,0x5d60,0x6580,0x6580,
0x6da0,0x6da0,0x75c0,0x75c0,0x7de0,0x8600,0x8600,
0x8e20,0x8e20,0x9640,0x9640,0x9e60,0xa680,0xa680,
0xaea0,0xaea0,0xb6c0,0xbec0,0xbee0,0xc700,0xc700,
0xcf20,0xcf20,0xd740,0xdf40,0xdf60,0xe780,0xe780,
0xefa0,0xefa0,0xf7c0,0xffe0,0xffe0,0xffe0,0xffe0,
0xffc0,0xffc0,0xffa0,0xffa0,0xffa0,0xff80,0xff80,
0xff60,0xff60,0xff60,0xff40,0xff40,0xff20,0xff20,
0xff00,0xff00,0xff00,0xfee0,0xfee0,0xfec0,0xfec0,
0xfec0,0xfea0,0xfea0,0xfe80,0xfe80,0xfe80,0xfe60,
0xfe60,0xfe40,0xfe40,0xfe40,0xfe20,0xfe20,0xfe00,
0xfe00,0xfde0,0xfde0,0xfde0,0xfdc0,0xfdc0,0xfda0,
0xfda0,0xfda0,0xfd80,0xfd80,0xfd60,0xfd60,0xfd60,
0xfd40,0xfd40,0xfd20,0xfd20,0xfd00,0xfd00,0xfce0,
0xfcc0,0xfca0,0xfca0,0xfc80,0xfc60,0xfc40,0xfc40,
0xfc20,0xfc00,0xfbe0,0xfbe0,0xfbc0,0xfba0,0xfb80,
0xfb80,0xfb60,0xfb40,0xfb20,0xfb20,0xfb00,0xfae0,
0xfac0,0xfac0,0xfaa0,0xfa80,0xfa60,0xfa60,0xfa40,
0xfa20,0xfa00,0xfa00,0xf9e0,0xf9c0,0xf9a0,0xf9a0,
0xf980,0xf960,0xf940,0xf940};
#endif
#if colorMode == 2
const PROGMEM uint16_t camColors[] =
{0x0083,0x0083,0x0084,0x0084,0x00a4,0x00a4,0x00a4,0x00a4,0x08a4,0x08c5,0x08c5,0x08c5,0x08c5,
0x08c5,0x08e5,0x08e5,0x08e6,0x08e6,0x08e6,0x08e6,0x0906,0x0906,0x0906,0x0907,0x0907,0x0907,
0x0927,0x0927,0x0927,0x0927,0x0928,0x0928,0x0948,0x0948,0x0948,0x0948,0x0948,0x0949,0x0969,
0x0969,0x0969,0x0969,0x1169,0x0969,0x118a,0x118a,0x118a,0x118a,0x118a,0x118a,0x11aa,0x11ab,
0x11ab,0x11ab,0x11ab,0x11ab,0x11cb,0x11cb,0x11cc,0x11cc,0x11cc,0x11ec,0x11ec,0x11ec,0x11ed,
0x11ed,0x120d,0x120d,0x120d,0x120d,0x120d,0x120d,0x122e,0x122e,0x122e,0x122e,0x1a2e,0x122e,
0x1a4f,0x1a4f,0x1a4f,0x1a4f,0x1a4f,0x1a4f,0x1a6f,0x1a6f,0x1a70,0x1a70,0x1a70,0x1a70,0x1a90,
0x1a90,0x1a91,0x1a91,0x1a91,0x1a91,0x1ab1,0x1ab1,0x1ab1,0x1ab2,0x1ab2,0x1ab2,0x1ad2,0x1ad2,
0x1ad2,0x1ad2,0x1ad3,0x1af3,0x1af3,0x1af3,0x1af3,0x1af3,0x22f3,0x2314,0x2314,0x2314,0x2314,
0x2314,0x2334,0x2334,0x2335,0x2335,0x2335,0x2335,0x2355,0x2355,0x2355,0x2356,0x2356,0x2356,
0x2376,0x2376,0x2376,0x2376,0x2377,0x2377,0x2397,0x2397,0x2397,0x2397,0x2397,0x2398,0x23b8,
0x23b8,0x23b8,0x23b8,0x2bb8,0x2bb8,0x2bd9,0x2bd9,0x2bd9,0x2bd9,0x2bd9,0x2bd9,0x2bfa,0x2bfa,
0x2bfa,0x2bfa,0x2bfa,0x2c1a,0x2c1a,0x2c1a,0x2c1b,0x2c1b,0x2c3b,0x2c3b,0x2c3b,0x2c3b,0x2c3c,
0x2c3c,0x2c5c,0x2c5c,0x2c5c,0x2c5c,0x2c5c,0x2c5c,0x2c7d,0x2c7d,0x2c7d,0x2c7d,0x347d,0x2c7d,
0x349e,0x349e,0x349e,0x349e,0x349e,0x349e,0x34be,0x34bf,0x34bf,0x34bf,0x34bf,0x34bf,0x34df,
0x34df,0x34df,0x34df,0x34df,0x34df,0x34df,0x34df,0x34ff,0x34ff,0x34ff,0x34fe,0x34fe,0x34fe,
0x34fe,0x34fe,0x351e,0x351e,0x351e,0x351d,0x351d,0x351d,0x351d,0x351d,0x353d,0x353d,0x353d,
0x353d,0x353d,0x353c,0x353c,0x353c,0x353c,0x353c,0x355c,0x355c,0x355c,0x355c,0x355c,0x355b,
0x355b,0x355b,0x357b,0x357b,0x357b,0x357b,0x357b,0x357b,0x357a,0x357a,0x359a,0x359a,0x359a,
0x359a,0x359a,0x359a,0x359a,0x3599,0x3d99,0x3599,0x3db9,0x35b9,0x3db9,0x35b9,0x3db9,0x3db9,
0x3db9,0x3db8,0x3dd8,0x3dd8,0x3dd8,0x3dd8,0x3dd8,0x3dd8,0x3dd8,0x3dd8,0x3df8,0x3df7,0x3df7,
0x3df7,0x3df7,0x3df7,0x3df7,0x3df7,0x3df7,0x3df6,0x3e16,0x3e16,0x3e16,0x3e16,0x3e16,0x3e16,
0x3e16,0x3e16,0x3e36,0x3e35,0x3e35,0x3e35,0x3e35,0x3e35,0x3e35,0x3e35,0x3e55,0x3e55,0x3e55,
0x3e54,0x3e54,0x3e54,0x3e54,0x3e54,0x3e54,0x3e54,0x3e74,0x3e74,0x3e73,0x3e73,0x3e73,0x3e73,
0x3e73,0x3e73,0x3e93,0x3e93,0x3e93,0x3e92,0x3e92,0x3e92,0x3e92,0x3e92,0x3eb2,0x3eb2,0x3eb2,
0x3eb2,0x3eb2,0x3eb1,0x3eb1,0x3eb1,0x3ed1,0x3eb1,0x3ed1,0x3ed1,0x3ed1,0x3ed1,0x3ed1,0x3ed0,
0x3ed0,0x3ed0,0x3ef0,0x3ef0,0x3ef0,0x3ef0,0x3ef0,0x3ef0,0x3eef,0x3eef,0x3f0f,0x3f0f,0x3f0f,
0x3f0f,0x3f0f,0x3f0f,0x3f0f,0x3f0e,0x472e,0x3f2e,0x472e,0x3f2e,0x472e,0x3f2e,0x472e,0x472e,
0x472e,0x472d,0x474d,0x474d,0x474d,0x474d,0x474d,0x474d,0x474d,0x474d,0x476c,0x476c,0x476c,
0x476c,0x476c,0x476c,0x476c,0x476c,0x478c,0x478b,0x478b,0x478b,0x478b,0x478b,0x478b,0x478b,
0x478b,0x478b,0x47ab,0x47aa,0x47aa,0x47aa,0x47aa,0x47aa,0x47aa,0x47aa,0x47ca,0x47ca,0x47ca,
0x47c9,0x47c9,0x47c9,0x47c9,0x47c9,0x47e9,0x47e9,0x47e9,0x47e9,0x47e8,0x47e8,0x47e8,0x47e8,
0x47e8,0x47e8,0x47e8,0x47e8,0x4fe8,0x4fe8,0x4fe8,0x4fe8,0x4fe8,0x4fe8,0x4fe8,0x4fe8,0x4fe8,
0x4fe8,0x4fe8,0x57e7,0x57e7,0x57e7,0x57e7,0x57e7,0x57e7,0x57e7,0x57e7,0x57e7,0x57e7,0x57e7,
0x5fe7,0x5fe7,0x5fe7,0x5fe7,0x5fe7,0x5fe7,0x5fe7,0x5fe7,0x5fe7,0x5fe7,0x67e7,0x67e7,0x67e7,
0x67e6,0x67e7,0x67e6,0x67e6,0x67e6,0x67e6,0x67e6,0x6fe6,0x6fc6,0x6fe6,0x6fc6,0x6fe6,0x6fc6,
0x6fe6,0x6fc6,0x6fc6,0x6fc6,0x77c6,0x77c6,0x77c6,0x77c6,0x77c6,0x77c6,0x77c6,0x77c6,0x77c6,
0x77c5,0x7fc6,0x7fc5,0x7fc5,0x7fc5,0x7fc5,0x7fc5,0x7fc5,0x7fc5,0x7fc5,0x7fc5,0x87c5,0x87c5,
0x87c5,0x87c5,0x87c5,0x87c5,0x87c5,0x87c5,0x87c5,0x87c5,0x87c5,0x8fc5,0x8fc5,0x8fc5,0x8fc5,
0x8fc4,0x8fc5,0x8fc4,0x8fc4,0x8fc4,0x8fc4,0x97c4,0x97c4,0x97c4,0x97c4,0x97c4,0x97c4,0x97c4,
0x97c4,0x97a4,0x97c4,0x97a4,0x9fc4,0x9fa4,0x9fc4,0x9fa4,0x9fa4,0x9fa4,0x9fa4,0x9fa4,0x9fa4,
0x9fa3,0xa7a4,0xa7a3,0xa7a3,0xa7a3,0xa7a3,0xa7a3,0xa7a3,0xa7a3,0xa7a3,0xa7a3,0xafa3,0xafa3,
0xafa3,0xafa3,0xafa3,0xafa3,0xafa3,0xafa3,0xafa3,0xafa3,0xb7a3,0xb7a3,0xb7a3,0xb7a3,0xb7a3,
0xb7a2,0xb7a3,0xb7a2,0xb7a2,0xb7a2,0xbfa2,0xbfa2,0xbfa2,0xbfa2,0xbfa2,0xbfa2,0xbfa2,0xbfa2,
0xbfa2,0xbfa2,0xc7a2,0xc7a2,0xc7a2,0xc7a2,0xc7a2,0xc7a2,0xc7a2,0xc782,0xc7a2,0xc782,0xc7a2,
0xcf81,0xcfa2,0xcf81,0xcf81,0xcf81,0xcf81,0xcf81,0xcf81,0xcf81,0xcf81,0xcf81,0xd781,0xd781,
0xd781,0xd781,0xd781,0xd781,0xd781,0xd781,0xd781,0xd781,0xdf81,0xdf81,0xdf81,0xdf81,0xdf81,
0xdf80,0xdf81,0xdf80,0xdf80,0xdf80,0xe780,0xe780,0xe780,0xe780,0xe780,0xe780,0xe780,0xe780,
0xe780,0xe780,0xef80,0xef80,0xef80,0xef80,0xef80,0xef80,0xef80,0xef80,0xef80,0xef80,0xf780,
0xf760,0xf780,0xf760,0xf760,0xf760,0xf760,0xf760,0xf760,0xf760,0xf760,0xf760,0xf760,0xf740,
0xf740,0xf740,0xf740,0xf740,0xf740,0xf740,0xf740,0xf740,0xf740,0xf740,0xf740,0xf720,0xf721,
0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf721,0xf701,0xf701,0xf701,
0xf701,0xf701,0xf701,0xf701,0xf701,0xf701,0xf701,0xf701,0xf701,0xf6e1,0xf6e1,0xf6e1,0xf6e2,
0xf6e2,0xf6e2,0xf6e2,0xf6e2,0xf6e2,0xf6e2,0xf6e2,0xf6e2,0xf6c2,0xf6c2,0xf6c2,0xf6c2,0xf6c2,
0xf6c2,0xf6c2,0xf6c2,0xf6c2,0xf6c2,0xf6c2,0xf6c2,0xf6a2,0xf6a2,0xf6a2,0xf6a2,0xf6a2,0xf6a3,
0xf6a3,0xf6a3,0xf6a3,0xf6a3,0xf683,0xf6a3,0xf683,0xf683,0xf683,0xf683,0xf683,0xf683,0xf683,
0xf683,0xf683,0xf683,0xf663,0xf683,0xf663,0xf663,0xf663,0xf663,0xf663,0xf663,0xf663,0xf664,
0xf664,0xf664,0xf644,0xf644,0xf644,0xf644,0xf644,0xf644,0xf644,0xf644,0xf644,0xf644,0xf644,
0xf644,0xf624,0xf624,0xf624,0xf624,0xf624,0xf624,0xf624,0xf624,0xf624,0xf625,0xf624,0xf625,
0xf605,0xf605,0xf605,0xf605,0xf605,0xf605,0xf605,0xf605,0xf605,0xf605,0xf605,0xf605,0xf5e5,
0xf5e5,0xf5e5,0xf5e5,0xf5e5,0xf5e5,0xf5e5,0xf5e5,0xf5e5,0xf5e5,0xf5e5,0xf5e6,0xf5c5,0xf5c6,
0xf5c6,0xf5c6,0xf5c6,0xf5c6,0xf5c6,0xf5c6,0xf5c6,0xf5c6,0xf5c6,0xf5c6,0xf5a6,0xf5a6,0xf5a6,
0xf5a6,0xf5a6,0xf5a6,0xf5a6,0xf5a6,0xf5a6,0xf5a6,0xf5a6,0xf5a6,0xf586,0xf587,0xf586,0xf587,
0xf587,0xf587,0xf587,0xf587,0xf587,0xf587,0xf567,0xf587,0xf567,0xf567,0xf567,0xf567,0xf567,
0xf567,0xf567,0xf567,0xf567,0xf567,0xf547,0xf567,0xf547,0xf547,0xf547,0xf548,0xf547,0xf548,
0xf548,0xf548,0xf548,0xf548,0xf528,0xf528,0xf528,0xf528,0xf528,0xf528,0xf528,0xf528,0xf528,
0xf528,0xf508,0xf508,0xf508,0xf508,0xf508,0xf508,0xf4e8,0xf4e8,0xf4e8,0xf4e8,0xf4e8,0xf4c8,
0xf4c7,0xf4c7,0xf4c7,0xf4c7,0xf4a7,0xf4a7,0xf4a7,0xf4a7,0xf4a7,0xf4a7,0xf487,0xf487,0xf487,
0xf487,0xf487,0xf467,0xf467,0xf467,0xf467,0xf467,0xf447,0xf447,0xf447,0xf447,0xf447,0xf447,
0xf426,0xf426,0xf426,0xf426,0xf426,0xf406,0xf406,0xf406,0xf406,0xf406,0xf3e6,0xf3e6,0xf3e6,
0xf3e6,0xf3e6,0xf3e6,0xf3c6,0xf3c6,0xf3c6,0xf3c6,0xf3c6,0xf3a6,0xf3a6,0xf3a6,0xf3a6,0xf3a6,
0xf385,0xf385,0xf385,0xf385,0xf385,0xf385,0xf365,0xf365,0xf365,0xf365,0xf365,0xf345,0xf345,
0xf345,0xf345,0xf345,0xf325,0xf325,0xf325,0xf325,0xf325,0xf325,0xf305,0xf305,0xf305,0xf305,
0xf304,0xf2e4,0xf2e4,0xf2e4,0xf2e4,0xf2e4,0xf2c4,0xf2c4,0xf2c4,0xf2c4,0xf2c4,0xf2c4,0xf2a4,
0xf2a4,0xf2a4,0xf2a4,0xf2a4,0xfa84,0xf284,0xfa84,0xf284,0xfa84,0xf264,0xfa64,0xfa64,0xfa64,
0xfa63,0xfa63,0xfa43,0xfa43,0xfa43,0xfa43,0xfa43,0xfa23,0xfa23,0xfa23,0xfa23,0xfa23,0xfa03,
0xfa03,0xfa03,0xfa03,0xfa03,0xfa03,0xf9e3,0xf9e3,0xf9e3,0xf9e3,0xf9e3,0xf9e3,0xf9c3,0xf9c3,
0xf9c2,0xf9c2,0xf9a2,0xf9a2,0xf9a2,0xf9a2,0xf9a2,0xf9a2,0xf982,0xf982,0xf982,0xf982,0xf982,
0xf982,0xf962,0xf962,0xf962,0xf962,0xf942,0xf942,0xf942,0xf942,0xf942};
#endif
Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS,  TFT_DC, TFT_RST);

Adafruit_AMG88xx amg;
unsigned long delayTime;

float pixels[AMG88xx_PIXEL_ARRAY_SIZE];
//dont change optimize here, look for value at top
#if optimize > 0 & colorMode <2

byte pixelsbuf[AMG88xx_PIXEL_ARRAY_SIZE];

#endif

#if optimize > 0 & colorMode == 2
//we just doulbe buffer size to words instead of 256 level bytes because of more color data at least 1024 colors now, maybe more in future
int pixelsbuf[AMG88xx_PIXEL_ARRAY_SIZE];//we double size of array so it can handle larger numbers for larger color tables

#endif

#if interpolatemode >1 & colorMode ==2
int postbuffer[AMG88xx_PIXEL_ARRAY_SIZE*4];//this is a temp buffer
#endif


#if interpolatemode >1 & colorMode <2
byte postbuffer[AMG88xx_PIXEL_ARRAY_SIZE*4];//this is a temp buffer it will be removed later on. currently we sub sample store in this buffer, and sub sample again
#endif

//uint16_t displayPixelWidth, displayPixelHeight;
void subpixelagain(){//this loop is temporary
 

}

void setup() {
 // Serial.begin(9600);
 Serial.begin(115200);
    Serial.println(F("AMG88xx thermal camera!"));

    tft.initR(INITR_144GREENTAB);   // initialize a ST7735S chip, black tab
    tft.fillScreen(ST7735_BLACK);

#define    displayPixelWidth  tft.width() /8  //allows values to be hardcoded
#define    displayPixelHeight   tft.height() / 8

    //tft.setRotation(3);

    bool status;
    
    // default settings
    status = amg.begin();
    if (!status) {
        Serial.println(F("Could not find a valid AMG88xx sensor, check wiring!"));
        while (1);
    }
    
    Serial.println( F("-- Thermal Camera Test --"));
   
    delay(100); // let sensor boot up

}


// friends it may be magical bologna, but it speeds things up quite abit!
//it looks at buffered value, and only updates the greated changes pixel locations
//and once changed, the next sets of pixels get updated. this reduces noise and 
//increases data thruput to display by only updating if change, and if overloaded 
//by most change. faster performance if fewer pixels set to priority                          
//      data range  -->     ||  limit data  ||Fuzzy logic data reduction                                           
//=========================]|| to greatest  ||==========================
//   bandwith compressor    ||    changed   || (by james villeneuve 2018)
#define speedUpCompression 8 //lower number is faster (it sets priority pixels amount, however too much means rest of display updates more slowly)
// also includes code to make sure every pixel updates but at a slower rate (1/8)

//higher number precision means more change allowed for pixel noise

//noise suppression, what shows at lower limits goes to lowest color 
uint8_t compressionnumber;//this counts pixels processed, if to many processed we make compression flux higher
uint8_t compressionflux=50;//this number goes up and down depending on how many pixesl are changing (usually from noise)
byte runagain=0;//used to refesh different amounts, for example we only process 1/4 of low quality pixes to make sure refesh happens besides with difference
void loop() {
amg.readPixels(pixels);


 byte i=0;
 byte j=0; 
 byte k=0;

compressionnumber=0;// we reset each time thru
 runagain++;runagain=runagain&15; //we run this routing to update a few times0,1, maybe more later on
 while(k<8 ){ 
switch(k){// this allows j to do interleaving of page, when updates are slower, and improvese results of compressed bandwitdh
case 0: j=0; break;case 1: j=2; break;case 2: j=4; break;case 3: j=6; break;case 4: j=1; break;case 5: j=3; break;case 6: j=5; break;case 7: j=7; break;
          }
if (i>7){i=0;k++;}//here we run code that makes sense of supersubsamples, sample is done when i=8,k=16


// |
// V i . j ------>direction of display sensor. helps when figuring out interpolation
   #if colorMode <2
    int colorIndex = map(pixels[i+j*8], MINTEMP, MAXTEMP, 0, 255); //we resuse this sample 
    #else
    //trying to average pixle data//
     int colorIndex = map(pixels[i+j*8], MINTEMP, MAXTEMP, 0, 1023); //we resuse this sample 
   #endif
 
    //we now compress and only update pixels on screen that change the most! it works and over time they all change, but to be sure force updates
#if optimize >1 
   if  ((pixelsbuf[i+j*8] -colorIndex)>compressionflux ||(colorIndex-pixelsbuf[i+j*8]>compressionflux ||i+j*8==(i+j*8)|runagain )){//runagain value just esuresallows non priority pixel areas to update as well besides noise
    //we only draw if it is pixle with higher priority of change AND PIXEL IS NOT SAME COLOR ALREADY
#endif    
//below checks the buffer 
#if optimize >0 

if (colorIndex !=pixelsbuf[i+j*8]){
#endif
#if optimize >1   
if (i+j*8 !=(i+j*8)|runagain)    compressionnumber++;// we only count priority pixels, not ones with slower refresh
 
#endif    


#if interpolatemode == 0
   //this is original for display code pixel placement
   //there is also spi optimizations to allow spi bursts during pixel writes
    tft.fillRect(displayPixelWidth *j, displayPixelHeight * i,displayPixelWidth, displayPixelHeight,(uint16_t)pgm_read_word_near(camColors+colorIndex));
#endif




#if interpolatemode > 0
//how it updates when more than 2x2 sub pixels
int pixelSizeDivide= 2*interpolatemode ; 
//[0][4][8][c] or [0][2] //order reverses depending on sample interpolateSampleDir 
//[1][5][9][d]    [1][3]
//[2][6][a][e]
//[3][7][b][f]
  //fast subdivide low memory pixel enhancing code (by James Villeneuve 7-2018 also referencing MIT code and adafruit library for pixel placement code)
     
int interpolatesampledir2=1; if(i<4){interpolatesampledir2=1;}else{interpolatesampledir2=-1;}//top(1) or bottom quadrunt (-1)
int interpolateSampleDir =1;// left  (1) or right quadrunt (-1)
int offset=0;

//getsubpixelcolor()//side pixel,vertical pixil,LeftOrRigh,current pixel
if (j<4){interpolateSampleDir =1;}// we process left to right here . we need to change this so it scales with display resolution
         else{interpolateSampleDir =-1;offset=displayPixelHeight-displayPixelHeight/pixelSizeDivide;}//if past half way on display we sample in other direction
 //long timecount=micros();

// getsubpixelcolor(pixelSizerDivide);//side pixel,vertical pixil,LeftOrRigh,current pixel
for (int raster_x=0;raster_x !=(pixelSizeDivide*interpolateSampleDir)  ;raster_x += 1*interpolateSampleDir){ //done with != instead of <> so i could invert direction ;)
    for (int raster_y=0;raster_y != (pixelSizeDivide* interpolateSampleDir) ;raster_y += 1* interpolateSampleDir){ //0,1  
//we keep sample size from nieghbor pixels even when sample divides increase

#if colorMode <2
int  tempcolor= map(pixels[(i+(interpolatesampledir2+raster_y/(pixelSizeDivide/2)))+(j+(raster_x/(pixelSizeDivide/2)))*8], MINTEMP, MAXTEMP, 0, 255);//we constrain color after subsampling
#else
int  tempcolor= map(pixels[(i+(interpolatesampledir2+raster_y/(pixelSizeDivide/2)))+(j+(raster_x/(pixelSizeDivide/2)))*8], MINTEMP, MAXTEMP, 0, 1023);//we constrain color after subsampling
#endif

//next line changes the average of the color between the main pixel and the sub pixels
tempcolor=(( tempcolor*(pixelSizeDivide-raster_y)+ colorIndex*raster_y)/pixelSizeDivide+(tempcolor*(raster_x)+colorIndex*(pixelSizeDivide-raster_x))/pixelSizeDivide)/2;//subsample with real pixel and surounding pixels

// prebuffer[AMG88xx_PIXEL_ARRAY_SIZE*4]
//Serial.print("x:");
//Serial.print(raster_x/2);
//Serial.print(" y:");
//Serial.println(raster_y/2);
//tempcolor=(tempcolor+ colorIndex)/2;//subsample with real pixel and surounding pixels
#if colorMode < 2
tempcolor=constrain(tempcolor,0,255);//subsample with real pixel and surounding pixels
#else
tempcolor=constrain(tempcolor,0,1023);//subsample with real pixel and surounding pixels
#endif


//formated line below for easier reading
//*******place pixels*************
fillRectFast(displayPixelWidth *j
+offset+ (interpolateSampleDir*displayPixelWidth/pixelSizeDivide)*(raster_x*interpolateSampleDir), //we reduce pixle size and step over in raster extra pixels created
displayPixelHeight* i+offset+(interpolateSampleDir*displayPixelHeight/pixelSizeDivide)*(raster_y*interpolateSampleDir),
displayPixelWidth/pixelSizeDivide,//we divide width of pixels. /2,4,8,16 is fast and compiler can just do bit shift for it
displayPixelHeight/pixelSizeDivide,//we divide hieght of pixels.
(uint16_t)pgm_read_word_near(camColors+tempcolor));  //we update pixel location with new subsampled pixel.
//would it make sense to subdivide to color of pixel directly? yes except camcolors is set with colors translated for heat.
//timertemp=micros()-timertemp;//we stop counter and subtract time of routine
//Serial.println(timertemp);
   }//interpolatepixel_y 
}//interpolatepixel_x    
#endif

//below ends the check buffer loop
#if optimize >0 
}
#endif
#if optimize >1
    }
#endif
   //we update each pixel data
 #if optimise > 1
 //pixelsbuf[i+j*8]=colorIndex;
 #endif


      i++;   
//old way
  //         tft.fillRect(displayPixelHeight * (i /8), displayPixelWidth * (i % 8),
    //    displayPixelHeight, displayPixelWidth, camColors[colorIndex]);
 
  }

//we sample one time per frame 
 if (compressionnumber>speedUpCompression){if (compressionflux<255) {compressionflux+=1;};
 }//we increase range more slowly 
 else{
  if (compressionflux>0){compressionflux-=1;};
 }
 //here we rerun routine, but up resolution


}



